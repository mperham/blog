<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Eventmachine on Mike Perham</title>
    <link>https://www.mikeperham.com/tags/eventmachine/</link>
    <description>Recent content in Eventmachine on Mike Perham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Apr 2010 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.mikeperham.com/tags/eventmachine/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introducing Phat, an Asynchronous Rails app</title>
      <link>https://www.mikeperham.com/2010/04/03/introducing-phat-an-asynchronous-rails-app/</link>
      <pubDate>Sat, 03 Apr 2010 00:00:00 +0000</pubDate>
      
      <guid>https://www.mikeperham.com/2010/04/03/introducing-phat-an-asynchronous-rails-app/</guid>
      <description>Phat is my new Rails 2.3.5 application which runs 100% asynchronous, supporting many concurrent requests in a single Ruby process.
This is a new breed of Rails application which uses a new mode of execution available in Ruby 1.9: single Thread, multiple Fiber. Existing modes of execution suck:
Single thread harkens back to the days of Rails 1.x, where you started N mongrels to handle up to N concurrent requests. Multiple threads is better but still has fundamental issues in Ruby.</description>
    </item>
    
    <item>
      <title>Using ActiveRecord with EventMachine</title>
      <link>https://www.mikeperham.com/2010/03/30/using-activerecord-with-eventmachine/</link>
      <pubDate>Tue, 30 Mar 2010 00:00:00 +0000</pubDate>
      
      <guid>https://www.mikeperham.com/2010/03/30/using-activerecord-with-eventmachine/</guid>
      <description>Given all my work with Fibers and EventMachine over the last three months, it should come as no surprise that I&amp;rsquo;ve been working on infrastructure based on Fibers and EventMachine to get maximum scalability without the callback style of code which I dislike for many reasons. Watch my talk on scaling with EventMachine if you need more background on the problem.
Now that I have RabbitMQ, Cassandra, Solr and the Amazon AWS services evented, the only holdup was ActiveRecord.</description>
    </item>
    
    <item>
      <title>Asynchronous DNS Resolution</title>
      <link>https://www.mikeperham.com/2010/02/10/asynchronous-dns-resolution/</link>
      <pubDate>Wed, 10 Feb 2010 00:00:00 +0000</pubDate>
      
      <guid>https://www.mikeperham.com/2010/02/10/asynchronous-dns-resolution/</guid>
      <description>Ruby has a serious scalability problem most Rubyists are unaware of. When you lookup the IP address for a hostname, the entire Ruby process blocks by default. If you have a slow DNS server, your process can grind to a halt waiting for hostname resolution. Ruby comes standard with a fix, resolv-replace, which provides a DNS resolver that does not block the entire process. It does however block the Thread, like any other instance of blocking I/O.</description>
    </item>
    
    <item>
      <title>Scalable Ruby Processing with EventMachine</title>
      <link>https://www.mikeperham.com/2010/01/27/scalable-ruby-processing-with-eventmachine/</link>
      <pubDate>Wed, 27 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>https://www.mikeperham.com/2010/01/27/scalable-ruby-processing-with-eventmachine/</guid>
      <description>I gave a talk at Austin On Rails last night on using EventMachine, focused on maximizing concurrency when processing a message queue. There were a lot of questions, mostly revolving around the flow of execution within EventMachine code. To this point, there were two common stumbling points people seemed to have:
Ruby developers are not used to treating blocks as true callbacks where they are executing at some point in the future.</description>
    </item>
    
  </channel>
</rss>
