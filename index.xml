<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mike Perham</title>
    <link>https://www.mikeperham.com/</link>
    <description>Recent content on Mike Perham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Feb 2024 09:00:00 -0800</lastBuildDate>
    
	<atom:link href="https://www.mikeperham.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How does Sidekiq work?</title>
      <link>https://www.mikeperham.com/sidekiq-internals/</link>
      <pubDate>Sun, 04 Feb 2024 16:00:23 +0100</pubDate>
      
      <guid>https://www.mikeperham.com/sidekiq-internals/</guid>
      <description>2024-02-04
This article was originally published on DanSvetlov.me and is republished here with permission of the author. This article is relevant to Sidekiq v7.
Sidekiq is one of the most ubiquitous1 Ruby background job processors out there. To anybody who has worked with Ruby on and off Rails, it needs no introduction. Sidekiq has a 10+ year track record of being an efficient, battle-tested and simple-to-use solution for offloading the execution of application logic into the background.</description>
    </item>
    
    <item>
      <title>Supporting Dragonfly</title>
      <link>https://www.mikeperham.com/2024/02/01/supporting-dragonfly/</link>
      <pubDate>Thu, 01 Feb 2024 09:00:00 -0800</pubDate>
      
      <guid>https://www.mikeperham.com/2024/02/01/supporting-dragonfly/</guid>
      <description>For about 15 years, Redis has been the dominant choice for background job infrastructure in Ruby.
First used by Resque, Sidekiq adopted it also as a pragmatic choice which had already gained mass acceptance within the community. And so for the last 15 years, we&amp;rsquo;ve used Redis widely across the industry for caching, jobs and many different data munging tasks. However the only constant is change.
Dragonfly brings competition and new capabilities.</description>
    </item>
    
    <item>
      <title>Ruby HTTP Server from scratch</title>
      <link>https://www.mikeperham.com/2023/09/11/ruby-http-server-from-scratch/</link>
      <pubDate>Mon, 11 Sep 2023 12:27:34 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2023/09/11/ruby-http-server-from-scratch/</guid>
      <description>Recently I decided to add support for Kubernetes HTTP health checks to Sidekiq Enterprise. This means, within each Sidekiq worker process, we need to implement an HTTP server which listens on port X and simply returns 200/OK if the process is alive.
Notice we have really basic requirements here: no need for serving files or arbitrary dynamic content. We only respond to &amp;ldquo;/&amp;rdquo; so there&amp;rsquo;s no need for routes, paths or query parameter handling.</description>
    </item>
    
    <item>
      <title>Scaling Huge Transactional Datasets with Redis Cluster</title>
      <link>https://www.mikeperham.com/2023/05/08/scaling-huge-transactional-datasets-with-redis-cluster/</link>
      <pubDate>Mon, 08 May 2023 09:00:00 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2023/05/08/scaling-huge-transactional-datasets-with-redis-cluster/</guid>
      <description>&lt;p&gt;Recently I made some minor changes to Sidekiq Enterprise 7.1 in order to greatly increase the scalability of the Rate Limiter feature.
Redis has a little-known feature which allows you to safely use &lt;code&gt;MULTI&lt;/code&gt; transactions with multiple keys in a cluster.
This was a real learning experience for me so I thought other people might find this interesting.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introducing Sidekiq 7.0</title>
      <link>https://www.mikeperham.com/2022/10/27/introducing-sidekiq-7.0/</link>
      <pubDate>Thu, 27 Oct 2022 10:08:17 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2022/10/27/introducing-sidekiq-7.0/</guid>
      <description>I&amp;rsquo;m proud to announce, after nearly a year of work, Sidekiq 7.0 is now available. Sidekiq is the most popular background job system for Ruby, used by thousands of companies around the world. This release is our biggest, most splendiforous release ever!
What&amp;rsquo;s New? Metrics One thing I know: everybody loves big beautiful graphs! Sidekiq 7.0 has a major new feature for tracking and visualizing job execution times. Big thanks to @adamlogic of Rails Autoscale for implementing the new graphs and I hope you&amp;rsquo;ll agree he did a fantastic job.</description>
    </item>
    
    <item>
      <title>Sidekiq 7.0: Embedding</title>
      <link>https://www.mikeperham.com/2022/10/27/sidekiq-7.0-embedding/</link>
      <pubDate>Thu, 27 Oct 2022 09:21:22 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2022/10/27/sidekiq-7.0-embedding/</guid>
      <description>Sidekiq 7.0 can be embedded within another process so you do not need to run a separate Sidekiq process. This is called embedding.
Why? Why would you want to do this? Embedding can make for a simpler deployment: you deploy one larger process instead of two separate processes, now you only need to monitor and manage one process. Embedding also requires less total memory since both subsystems will share most of the Ruby data structures and code in memory.</description>
    </item>
    
    <item>
      <title>Sidekiq 7.0: Metrics</title>
      <link>https://www.mikeperham.com/2022/10/27/sidekiq-7.0-metrics/</link>
      <pubDate>Thu, 27 Oct 2022 09:20:55 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2022/10/27/sidekiq-7.0-metrics/</guid>
      <description>Sidekiq 7.0 introduces a new subsystem for gathering job execution data along with a new Metrics tab within the Web UI to visualize this data. The data is designed to help you answer a few questions:
Which types of jobs executed? Which types of jobs took the most amount of time to execute? How has the performance of Job X changed recently? When did any deploys occur during this time? The graphs only show data for the last hour.</description>
    </item>
    
    <item>
      <title>Sidekiq 7.0 Beta now Available</title>
      <link>https://www.mikeperham.com/2022/09/27/sidekiq-7.0-beta-now-available/</link>
      <pubDate>Tue, 27 Sep 2022 15:17:08 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2022/09/27/sidekiq-7.0-beta-now-available/</guid>
      <description>Yesterday I released the first public beta of Sidekiq 7.0. This is a major new release with several huge new features, several features removed, APIs refactored and updated requirements.
Job Performance Metrics! Embedded mode! Capsules! Strict args! But with all these awesome new features, we refactored a LOT of internal APIs and likely broke a bunch of things. In other words, we really need people to test it and open issues in order to get a smooth 7.</description>
    </item>
    
    <item>
      <title>Sidekiq and Request-Specific Context</title>
      <link>https://www.mikeperham.com/2022/07/29/sidekiq-and-request-specific-context/</link>
      <pubDate>Fri, 29 Jul 2022 19:43:06 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2022/07/29/sidekiq-and-request-specific-context/</guid>
      <description>At some point in growing a large-scale software system, you&amp;rsquo;ll require &amp;ldquo;out of band&amp;rdquo; context: data which is not explicitly passed as an argument to a function but rather implicitly attached to the request, job or event being processed. Usually context is implemented as thread-local variables; your code first sets up the necessary context and then processes the request. A common example is multi-tenancy: you might want to limit any data queried by a given request to a database schema specific to a given tenant.</description>
    </item>
    
    <item>
      <title>Modernizing Einhorn</title>
      <link>https://www.mikeperham.com/2022/07/14/modernizing-einhorn/</link>
      <pubDate>Thu, 14 Jul 2022 08:41:10 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2022/07/14/modernizing-einhorn/</guid>
      <description>Einhorn is a Ruby gem which provides the ability to manage multiple forked processes of Unix services. Stripe originally built Einhorn to manage their internal collection of services in production but stopped actively maintaining the gem several years ago. I recently asked for and was granted ownership of the gem so that I could provide maintenance going forward. This blog post is meant to document how I took over and what I did, I hope others find this interesting and perhaps even useful.</description>
    </item>
    
  </channel>
</rss>
