<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mike Perham</title>
    <link>https://www.mikeperham.com/</link>
    <description>Recent content on Mike Perham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 03 Jul 2024 09:00:00 -0700</lastBuildDate>
    
	<atom:link href="https://www.mikeperham.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Iteration and Sidekiq 7.3.0</title>
      <link>https://www.mikeperham.com/2024/07/03/iteration-and-sidekiq-7.3.0/</link>
      <pubDate>Wed, 03 Jul 2024 09:00:00 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2024/07/03/iteration-and-sidekiq-7.3.0/</guid>
      <description>Sidekiq is the most popular background job framework for Ruby and works really well if you follow the design guidelines: keep your jobs short and idempotent. What happens if you have a job which processes a large amount of data serially, the infamous long-running job? In that case, deployments can lead to the job failing mid-way because the job will not gracefully allow the Sidekiq process to restart. To fix this, Sidekiq 7.</description>
    </item>
    
    <item>
      <title>Redis Licensing Changes and You</title>
      <link>https://www.mikeperham.com/2024/04/22/redis-licensing-changes-and-you/</link>
      <pubDate>Mon, 22 Apr 2024 08:53:20 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2024/04/22/redis-licensing-changes-and-you/</guid>
      <description>A few weeks ago, the owners of Redis changed its licensing from BSD to a more limited source available license. As far as I know this was done in order to prevent service providers from adding their own closed source, proprietary changes to their Redis service offerings.
In principle I like this change.
My Faktory project uses the AGPL license for the same purpose: Faktory is open source and anyone who offers Faktory as a service with proprietary changes should have to open source those changes too.</description>
    </item>
    
    <item>
      <title>Serializing Ruby datatypes in JSON</title>
      <link>https://www.mikeperham.com/2024/03/01/serializing-ruby-datatypes-in-json/</link>
      <pubDate>Fri, 01 Mar 2024 09:42:08 -0800</pubDate>
      
      <guid>https://www.mikeperham.com/2024/03/01/serializing-ruby-datatypes-in-json/</guid>
      <description>Ruby&amp;rsquo;s JSON library allows you to convert Ruby datatypes into a JSON document, as long as those types are native to JSON: String, bool, int, float, nil, Hash and Array. Everything else converts to a String by default; if you use any other core datatypes, they will not survive a JSON.generate/JSON.parse round trip. Here I pass a Range, Symbol and Time; notice how the end result is three Strings instead of the actual types:</description>
    </item>
    
    <item>
      <title>How does Sidekiq work?</title>
      <link>https://www.mikeperham.com/2024/02/22/how-does-sidekiq-work/</link>
      <pubDate>Thu, 22 Feb 2024 10:59:46 -0800</pubDate>
      
      <guid>https://www.mikeperham.com/2024/02/22/how-does-sidekiq-work/</guid>
      <description>A few weeks ago, I sat gobsmacked at my laptop reading one of the most impressive technical deep dives I&amp;rsquo;ve ever read. Dan Svetlov wrote a blog post &amp;ldquo;How does Sidekiq really work?&amp;rdquo; on his blog which delved deep into Sidekiq&amp;rsquo;s internals, explaining how it actually works. The most impressive part of this blog post is that it was 100% accurate. There were no mistakes or misunderstandings, Dan did the work and shows the receipts.</description>
    </item>
    
    <item>
      <title>How does Sidekiq work?</title>
      <link>https://www.mikeperham.com/how-sidekiq-works/</link>
      <pubDate>Sun, 04 Feb 2024 16:00:23 +0100</pubDate>
      
      <guid>https://www.mikeperham.com/how-sidekiq-works/</guid>
      <description>2024-02-04
This article was originally published on DanSvetlov.me and is republished here with permission of the author. This article is relevant to Sidekiq v7.
Sidekiq is one of the most ubiquitous1 Ruby background job processors out there. To anybody who has worked with Ruby on and off Rails, it needs no introduction. Sidekiq has a 10+ year track record of being an efficient, battle-tested and simple-to-use solution for offloading the execution of application logic into the background.</description>
    </item>
    
    <item>
      <title>Supporting Dragonfly</title>
      <link>https://www.mikeperham.com/2024/02/01/supporting-dragonfly/</link>
      <pubDate>Thu, 01 Feb 2024 09:00:00 -0800</pubDate>
      
      <guid>https://www.mikeperham.com/2024/02/01/supporting-dragonfly/</guid>
      <description>For about 15 years, Redis has been the dominant choice for background job infrastructure in Ruby.
First used by Resque, Sidekiq adopted it also as a pragmatic choice which had already gained mass acceptance within the community. And so for the last 15 years, we&amp;rsquo;ve used Redis widely across the industry for caching, jobs and many different data munging tasks. However the only constant is change.
Dragonfly brings competition and new capabilities.</description>
    </item>
    
    <item>
      <title>Ruby HTTP Server from scratch</title>
      <link>https://www.mikeperham.com/2023/09/11/ruby-http-server-from-scratch/</link>
      <pubDate>Mon, 11 Sep 2023 12:27:34 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2023/09/11/ruby-http-server-from-scratch/</guid>
      <description>Recently I decided to add support for Kubernetes HTTP health checks to Sidekiq Enterprise. This means, within each Sidekiq worker process, we need to implement an HTTP server which listens on port X and simply returns 200/OK if the process is alive.
Notice we have really basic requirements here: no need for serving files or arbitrary dynamic content. We only respond to &amp;ldquo;/&amp;rdquo; so there&amp;rsquo;s no need for routes, paths or query parameter handling.</description>
    </item>
    
    <item>
      <title>Scaling Huge Transactional Datasets with Redis Cluster</title>
      <link>https://www.mikeperham.com/2023/05/08/scaling-huge-transactional-datasets-with-redis-cluster/</link>
      <pubDate>Mon, 08 May 2023 09:00:00 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2023/05/08/scaling-huge-transactional-datasets-with-redis-cluster/</guid>
      <description>&lt;p&gt;Recently I made some minor changes to Sidekiq Enterprise 7.1 in order to greatly increase the scalability of the Rate Limiter feature.
Redis has a little-known feature which allows you to safely use &lt;code&gt;MULTI&lt;/code&gt; transactions with multiple keys in a cluster.
This was a real learning experience for me so I thought other people might find this interesting.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introducing Sidekiq 7.0</title>
      <link>https://www.mikeperham.com/2022/10/27/introducing-sidekiq-7.0/</link>
      <pubDate>Thu, 27 Oct 2022 10:08:17 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2022/10/27/introducing-sidekiq-7.0/</guid>
      <description>I&amp;rsquo;m proud to announce, after nearly a year of work, Sidekiq 7.0 is now available. Sidekiq is the most popular background job system for Ruby, used by thousands of companies around the world. This release is our biggest, most splendiforous release ever!
What&amp;rsquo;s New? Metrics One thing I know: everybody loves big beautiful graphs! Sidekiq 7.0 has a major new feature for tracking and visualizing job execution times. Big thanks to @adamlogic of Rails Autoscale for implementing the new graphs and I hope you&amp;rsquo;ll agree he did a fantastic job.</description>
    </item>
    
    <item>
      <title>Sidekiq 7.0: Embedding</title>
      <link>https://www.mikeperham.com/2022/10/27/sidekiq-7.0-embedding/</link>
      <pubDate>Thu, 27 Oct 2022 09:21:22 -0700</pubDate>
      
      <guid>https://www.mikeperham.com/2022/10/27/sidekiq-7.0-embedding/</guid>
      <description>Sidekiq 7.0 can be embedded within another process so you do not need to run a separate Sidekiq process. This is called embedding.
Why? Why would you want to do this? Embedding can make for a simpler deployment: you deploy one larger process instead of two separate processes, now you only need to monitor and manage one process. Embedding also requires less total memory since both subsystems will share most of the Ruby data structures and code in memory.</description>
    </item>
    
  </channel>
</rss>
